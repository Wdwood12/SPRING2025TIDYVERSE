---
title: "Lubridate Package"
author: "Miraj Patel"
date: "2025-04-20"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

##Introduction

In this vignette, we will use lubridate package from the Tidyverse to parse and manipulate data that uses date and time. The data we will use is flights dataset in nycflights13 package. We will calculate departure delays and visualize the results. 

###Load Data and Perform Analysis

First, lets install and load the necessary libraries. 

```{r}
# install.packages("tidyverse")
# install.packages("lubridate")
# install.packages("nycflights13")

library(tidyverse)
library(lubridate)
library(nycflights13)
```

Let's load the flight dataset and get a glimpse of the dataset. 

```{r}
flights <- nycflights13::flights
glimpse(flights)
```

After the glimpse of the dataset, we will use functions in the lubridate package to convert date and time columns into proper datetime objects.

```{r}

flights <- flights %>%
  mutate(
    flight_date = make_date(year, month, day),
    sched_dep_time = str_pad(sched_dep_time, 4, pad = "0"), # fixed string width of 4 otherwise creates problems with sched_departure_time
    dep_time = str_pad(dep_time, 4, pad = "0"),
    sched_departure_time = parse_time(as.character(sched_dep_time), format = "%H%M"), 
    actual_departure_time = parse_time(as.character(dep_time), format = "%H%M")
  )

```

With this, we have 3 new columns in the dataset. The date is combined into one column and the times are combined into one column for easier readability and analysis. 

Next, we will convert the departure delay values into a numeric format for easier analysis. Then we will summarize the average departure delay for each day of the week and create a visualization to present the findings. 

We will use wday function from the lubridate package to figure out what day of the week the date of departure fell on. 

```{r}
#Calculate delay in minutes
flights <- flights %>%
  mutate(departure_delay_minutes = as.numeric(dep_delay))

#Add a day of the week column
flights <- flights %>%
  mutate(day_of_week = wday(flight_date, label = TRUE))

#Summarize average delay by day of the week
average_delay <- flights %>%
  group_by(day_of_week) %>%
  summarize(average_delay = mean(departure_delay_minutes, na.rm = TRUE))

#Plot the results
ggplot(average_delay, aes(x = day_of_week, y = average_delay)) +
  geom_bar(stat = "identity") +
  labs(
    title = "Average Departure Delay by Day of the Week",
    x = "Day of the Week",
    y = "Average Departure Delay (minutes)"
  )

```

##Conclusion

In this vignette, we utilized the lubridate package to parse and manipulate date and time data in one of the nycflights13 dataset. We calculated departure delays and visualized the average delays by each day of the week. Using lubridate package made it easier to perfrom these analyses. 

## Extending example with map2_dbl from purrr

Let's operate on flights to see which carrier has the lowest median flight. This could tell us which carrier typically does not have flights outside of a small range.

We will use `map2_dbl` from `purrr` for the example. There are many other ways to combine hours and minutes together into a consistent form, but this allows us to see the power of mapping functions in `purrr`. You can create short custom in-line functions using ~ in one of the map functions. Hour * 60 + minute is a simple calculation and is suited for this purpose. Afterwards, group the separate flights for each carrier together and find the median minutes for them. 

```{r}
flight_durations <- flights %>% 
  mutate(
    minutes = map2_dbl(hour, minute, ~(.x * 60 + .y))
  ) %>%
  select(carrier, minutes)

carrier_median_duration <- flight_durations %>%
  group_by(carrier) %>%
  summarise(median = median(minutes))

carrier_median_duration %>% 
  ggplot(aes(carrier, median)) +
  geom_col() +
  theme_classic() +
  labs(x = 'Carrier Code', y = 'Median Minutes', title = 'Median minutes per flight by carrier')
  
```

In this example, HA or Hawaiian Airlines had the shortest flight duration. With further analysis we would likely find that HA flights likely are local to Hawaii while the other carriers are more likely to traverse different states.



## Time Zones Handling

```{r}

flights <- flights %>%
  mutate(dep_time_new_york = with_tz(actual_departure_time, tzone = "America/New_York"))

head(flights$dep_time_new_york)

```
## Adding a Date Range Filter
Displaying flight of a selected date range. Then will visulize post summary.
```{r}

flights_filtered <- flights %>%
  filter(flight_date >= make_date(2013, 1, 1) & flight_date <= make_date(2013, 12, 31))

# Summarize and visualize
flights_filtered %>%
  group_by(day_of_week) %>%
  summarise(avg_delay = mean(departure_delay_minutes, na.rm = TRUE)) %>%
  ggplot(aes(x = day_of_week, y = avg_delay)) +
  geom_bar(stat = "identity") +
  labs(title = "Average Departure Delay by Day of Week in 2013")

```
## Create Custom Date Function

With lubridate custom date-time can be created, and future combinations for advance manipulatioin.

```{r}
# Function to calculate the time difference in minutes between scheduled and actual departure
time_difference <- function(scheduled_time, actual_time) {
  as.numeric(difftime(actual_time, scheduled_time, units = "mins"))
}

# Apply function to dataset
flights <- flights %>%
  mutate(time_diff = mapply(time_difference, sched_departure_time, actual_departure_time))

# Visualize the time difference
ggplot(flights, aes(x = time_diff)) +
  geom_histogram(bins = 30) +
  labs(
    title = "Time Difference Between Scheduled and Actual Departure",
    x = "Time Difference (minutes)",
    y = "Frequency"
  )

```
## Conclusion
The following extension will enhanced the original vignette to a broader analysis, 
introducing functionality from lubridate, will help demonstrate more effectively to visualize time pattern.